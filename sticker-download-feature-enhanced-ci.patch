From 50ba2263109009cc0dc1dc250d170927368e9e42 Mon Sep 17 00:00:00 2001
From: AI Assistant <ai-assistant@example.com>
Date: Fri, 17 Oct 2025 13:36:24 +0800
Subject: [PATCH 1/2] =?UTF-8?q?feat:=20=E6=B7=BB=E5=8A=A0=E8=B4=B4?=
 =?UTF-8?q?=E7=BA=B8=E5=8C=85=E4=B8=8B=E8=BD=BD=E5=8A=9F=E8=83=BD?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- 在StickerService中添加贴纸包下载功能
- 支持批量下载贴纸到本地设备
- 添加下载进度跟踪和错误处理
- 支持多种贴纸格式(.png, .tgs, .mp4)
- 更新TelegramBotBackgroundService支持下载命令
- 完善README.md文档和使用说明
- 添加/download和/help_download快捷命令

Co-authored-by: dakou <dakou@iflow.cn>
---
 README.md                                   |  30 +++
 src/Service/StickerService.cs               | 229 ++++++++++++++++++++
 src/Service/TelegramBotBackgroundService.cs |  10 +
 3 files changed, 269 insertions(+)

diff --git a/README.md b/README.md
index 0e68c09..535b1c0 100644
--- a/README.md
+++ b/README.md
@@ -8,6 +8,7 @@
 ## ✨ 项目亮点
 
 - 💎 支持 Telegram 贴纸 和 表情 的克隆操作
+- 💾 支持贴纸包批量下载到本地设备
 - 🧠 智能识别用户输入格式
 - 🔄 支持命令格式解析自动克隆
 - ⚙️ 基于 .NET 9.0 构建，性能可靠
@@ -61,4 +62,33 @@
 请确保信息填写正确，以便程序顺利克隆哦～ 🚀
 ```
 
+### 贴纸包下载功能
+您还可以下载指定贴纸包中的所有贴纸到本地设备：
+
+```
+💾 贴纸包下载使用说明 💾
+
+您可以下载指定贴纸包中的所有贴纸到本地设备。使用方法如下：
+
+下载#目标文件夹路径#贴纸包链接
+
+例如：
+下载#./Downloads/my-stickers#https://t.me/addstickers/animals_collection
+
+🔹 下载：命令前缀，触发下载操作
+🔹 目标文件夹路径：存放下载贴纸的本地文件夹路径
+🔹 贴纸包链接：要下载的Telegram贴纸包链接
+
+注意：
+- 请确保有足够的磁盘空间存储贴纸文件
+- 大型贴纸包可能需要较长的下载时间
+- 建议在网络良好的环境下进行操作
+```
+
+### 快捷命令
+- `/start` - 启动机器人
+- `/info` - 查看项目信息
+- `/download` - 下载贴纸包
+- `/help_download` - 查看下载帮助
+
 ------
diff --git a/src/Service/StickerService.cs b/src/Service/StickerService.cs
index 33dfada..4d48bba 100644
--- a/src/Service/StickerService.cs
+++ b/src/Service/StickerService.cs
@@ -4,11 +4,13 @@ public class StickerService
 {
     private readonly ILogger<StickerService> _logger;
     private readonly MessageService _messageService;
+    private readonly HttpClient _httpClient;
 
     public StickerService(ILogger<StickerService> logger, MessageService messageService)
     {
         _logger = logger;
         _messageService = messageService;
+        _httpClient = new HttpClient(); // 用于下载贴纸文件的HttpClient实例
     }
 
     public async Task SendStickerInstructionsAsync(Bot bot, Telegram.Bot.Types.Message msg)
@@ -231,4 +233,231 @@ public class StickerService
         ValidatePackName(packName);
         return packName;
     }
+
+    /// <summary>
+    /// 发送贴纸包下载使用说明
+    /// </summary>
+    public async Task SendDownloadInstructionsAsync(Bot bot, Telegram.Bot.Types.Message msg)
+    {
+        var messageText = new StringBuilder()
+            .AppendLine("💾 <b>贴纸包下载使用说明</b> 💾")
+            .AppendLine()
+            .AppendLine("您可以下载指定贴纸包中的所有贴纸到本地设备。使用方法如下：")
+            .AppendLine()
+            .AppendLine("<code>下载#目标文件夹路径#贴纸包链接</code>")
+            .AppendLine()
+            .AppendLine("例如：")
+            .AppendLine("<code>下载#./Downloads/my-stickers#https://t.me/addstickers/animals_collection</code>")
+            .AppendLine()
+            .AppendLine("🔹 <b>下载</b>：命令前缀，触发下载操作")
+            .AppendLine("🔹 <b>目标文件夹路径</b>：存放下载贴纸的本地文件夹路径")
+            .AppendLine("🔹 <b>贴纸包链接</b>：要下载的Telegram贴纸包链接")
+            .AppendLine()
+            .AppendLine("注意：")
+            .AppendLine("- 请确保有足够的磁盘空间存储贴纸文件")
+            .AppendLine("- 大型贴纸包可能需要较长的下载时间")
+            .AppendLine("- 建议在网络良好的环境下进行操作")
+            .ToString();
+
+        await _messageService.SendMessageAsync(bot, msg.Chat.Id, messageText, replyParameters: msg);
+    }
+
+    /// <summary>
+    /// 处理贴纸包下载命令
+    /// </summary>
+    public async Task HandleDownloadCommandAsync(Bot bot, Telegram.Bot.Types.Message msg)
+    {
+        try
+        {
+            string[] parts = msg.Text.Split('#');
+
+            if (parts.Length != 3)
+            {
+                var errorMsg = new StringBuilder()
+                    .AppendLine("格式错误！请使用正确的格式：")
+                    .Append("下载#目标文件夹路径#贴纸包链接")
+                    .ToString();
+
+                await _messageService.SendMessageAsync(bot, msg.Chat.Id, errorMsg, replyParameters: msg);
+                return;
+            }
+
+            string downloadDirectory = parts[1].Trim();
+            string stickerUrl = parts[2];
+
+            if (!stickerUrl.StartsWith("https://t.me/add"))
+            {
+                await _messageService.SendMessageAsync(bot, msg.Chat.Id,
+                    "贴纸链接格式错误！链接应该以 https://t.me/add 开头",
+                    replyParameters: msg);
+                return;
+            }
+
+            string stickerSetName = stickerUrl
+                .Replace("https://t.me/addstickers/", "")
+                .Replace("https://t.me/addemoji/", "");
+
+            var statusMessage = $"💾 正在准备下载贴纸包，请稍候...\n此过程可能需要几分钟，取决于贴纸数量和大小。";
+            var statusMessageId = await _messageService.SendMessageAsync(bot, msg.Chat.Id, statusMessage);
+
+            _ = Task.Run(async () => await ProcessDownloadStickerTaskAsync(
+                bot, msg, statusMessageId, stickerSetName, downloadDirectory));
+        }
+        catch (Exception ex)
+        {
+            var errorBuilder = $"[错误] 发生异常: {ex.Message}";
+            _logger.LogError(ex, "处理下载命令时发生异常");
+            await _messageService.SendMessageAsync(bot, msg.Chat.Id, errorBuilder);
+        }
+    }
+
+    /// <summary>
+    /// 异步处理贴纸包下载任务
+    /// </summary>
+    private async Task ProcessDownloadStickerTaskAsync(
+        Bot bot,
+        Telegram.Bot.Types.Message msg,
+        int statusMessageId,
+        string stickerSetName,
+        string downloadDirectory)
+    {
+        List<(string fileName, Exception error)> downloadErrors = new List<(string, Exception)>();
+        
+        try
+        {
+            // 创建下载目录
+            Directory.CreateDirectory(downloadDirectory);
+
+            // 获取贴纸包信息
+            var stickerSet = await bot.GetStickerSet(stickerSetName);
+            
+            var statusBuilder = new StringBuilder()
+                .AppendLine("📦 贴纸包信息:")
+                .AppendLine($"标题: {stickerSet.Title}")
+                .AppendLine($"贴纸数量: {stickerSet.Stickers.Length}")
+                .AppendLine($"类型: {stickerSet.StickerType}")
+                .AppendLine($"下载位置: {Path.GetFullPath(downloadDirectory)}")
+                .AppendLine()
+                .Append("⬇️ 开始下载贴纸...");
+
+            await _messageService.EditMessageAsync(bot, msg.Chat.Id, statusMessageId, statusBuilder.ToString());
+
+            int downloadedCount = 0;
+            int totalCount = stickerSet.Stickers.Length;
+
+            // 逐个下载贴纸
+            for (int i = 0; i < totalCount; i++)
+            {
+                var sticker = stickerSet.Stickers[i];
+                
+                try
+                {
+                    // 更新进度状态
+                    await _messageService.EditMessageAsync(bot, msg.Chat.Id, statusMessageId,
+                        $"[进度] 正在下载第 {i + 1}/{totalCount} 个贴纸\n已完成: {downloadedCount}/{totalCount}");
+
+                    // 获取贴纸文件信息
+                    var fileInfo = await bot.GetFile(sticker.FileId);
+                    
+                    if (fileInfo == null)
+                    {
+                        downloadErrors.Add((GetFileName(i, sticker), new Exception("无法获取文件信息")));
+                        continue;
+                    }
+
+                    // 确定文件扩展名
+                    string extension = GetStickerExtension(fileInfo);
+                    string fileName = $"{stickerSet.Name}_{i:D3}{extension}";
+                    string filePath = Path.Combine(downloadDirectory, fileName);
+
+                    // 下载文件
+                    await DownloadStickerFileAsync(bot, fileInfo.FilePath, filePath);
+                    
+                    downloadedCount++;
+                    
+                    // 短暂延迟以避免请求过于频繁
+                    await Task.Delay(200);
+                }
+                catch (Exception ex)
+                {
+                    downloadErrors.Add((GetFileName(i, sticker), ex));
+                    _logger.LogWarning(ex, "下载贴纸失败: {Index}/{Total}", i + 1, totalCount);
+                }
+            }
+
+            // 生成最终结果消息
+            var finalMessageBuilder = new StringBuilder()
+                .AppendLine("✅ 贴纸包下载完成！")
+                .AppendLine()
+                .AppendLine($"📁 下载位置: {Path.GetFullPath(downloadDirectory)}")
+                .AppendLine($"📝 贴纸包标题: {stickerSet.Title}")
+                .AppendLine($"🔢 总数: {totalCount} 个贴纸")
+                .AppendLine($"✅ 成功下载: {downloadedCount} 个")
+                .AppendLine($"❌ 失败: {downloadErrors.Count} 个");
+
+            if (downloadErrors.Any())
+            {
+                finalMessageBuilder.AppendLine().AppendLine("⚠️ 失败的贴纸:");
+                foreach (var (fileName, error) in downloadErrors.Take(5)) // 只显示前5个错误
+                {
+                    finalMessageBuilder.AppendLine($"- {fileName}: {error.Message}");
+                }
+                if (downloadErrors.Count > 5)
+                {
+                    finalMessageBuilder.AppendLine($"- ...还有 {downloadErrors.Count - 5} 个错误");
+                }
+            }
+
+            await _messageService.EditMessageAsync(bot, msg.Chat.Id, statusMessageId, finalMessageBuilder.ToString());
+        }
+        catch (Exception ex)
+        {
+            var errorBuilder = new StringBuilder()
+                .AppendLine("❌ 下载过程中出现错误：")
+                .AppendLine(ex.Message)
+                .AppendLine()
+                .Append("请检查网络连接和目标文件夹权限后重试。");
+
+            await _messageService.EditMessageAsync(bot, msg.Chat.Id, statusMessageId, errorBuilder.ToString());
+            _logger.LogError(ex, $"下载贴纸包时发生错误 - 用户ID: {msg.From.Id}, 贴纸包: {stickerSetName}");
+        }
+    }
+
+    /// <summary>
+    /// 下载单个贴纸文件
+    /// </summary>
+    private async Task DownloadStickerFileAsync(Bot bot, string filePath, string destinationPath)
+    {
+        try
+        {
+            // 使用Telegram Bot API下载文件
+            using var fileStream = new FileStream(destinationPath, FileMode.Create, FileAccess.Write);
+            await bot.DownloadFile(filePath, fileStream);
+        }
+        catch (Exception ex)
+        {
+            throw new Exception($"下载文件失败: {ex.Message}", ex);
+        }
+    }
+
+    /// <summary>
+    /// 根据文件信息获取贴纸文件扩展名
+    /// </summary>
+    private string GetStickerExtension(WTelegram.Types.File fileInfo)
+    {
+        if (fileInfo.MimeType?.Contains("video") == true)
+            return ".mp4";
+        else if (fileInfo.MimeType?.Contains("animated") == true)
+            return ".tgs"; // Telegram动画贴纸格式
+        else
+            return ".png"; // 静态贴纸默认使用PNG格式
+    }
+
+    /// <summary>
+    /// 生成文件名
+    /// </summary>
+    private string GetFileName(int index, Sticker sticker)
+    {
+        return $"sticker_{index:D3}{(sticker.Emoji != null ? "_" + sticker.Emoji.Replace(" ", "") : "")}";
+    }
 }
\ No newline at end of file
diff --git a/src/Service/TelegramBotBackgroundService.cs b/src/Service/TelegramBotBackgroundService.cs
index 62455d8..d1efe23 100644
--- a/src/Service/TelegramBotBackgroundService.cs
+++ b/src/Service/TelegramBotBackgroundService.cs
@@ -76,6 +76,8 @@ public class TelegramBotBackgroundService : BackgroundService
         {
             new Telegram.Bot.Types.BotCommand { Command = "start", Description = "启动机器人" },
             new Telegram.Bot.Types.BotCommand { Command = "info", Description = "关于" },
+            new Telegram.Bot.Types.BotCommand { Command = "download", Description = "下载贴纸包" },
+            new Telegram.Bot.Types.BotCommand { Command = "help_download", Description = "下载帮助" },
         };
 
         foreach (var cmd in commands)
@@ -152,5 +154,13 @@ public class TelegramBotBackgroundService : BackgroundService
         {
             await _stickerService.SendStickerInfoAsync(bot, msg);
         }
+        else if (text.StartsWith("下载#") || text.StartsWith("/download") || text.Contains("download"))
+        {
+            await _stickerService.HandleDownloadCommandAsync(bot, msg);
+        }
+        else if (text.StartsWith("/help_download") || text.Contains("帮助下载"))
+        {
+            await _stickerService.SendDownloadInstructionsAsync(bot, msg);
+        }
     }
 }
\ No newline at end of file
-- 
2.43.0


From b87e78fb0ced2de6dd03a9cf8853bbe8537ee5f8 Mon Sep 17 00:00:00 2001
From: AI Assistant <ai-assistant@example.com>
Date: Fri, 17 Oct 2025 13:52:08 +0800
Subject: [PATCH 2/2] =?UTF-8?q?ci:=20=E5=A2=9E=E5=BC=BAGitHub=20Actions?=
 =?UTF-8?q?=E7=BC=96=E8=AF=91=E7=AE=A1=E9=81=93?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- 在构建阶段添加基础代码质量检查
- 包括依赖恢复和编译验证步骤
- 提高CI/CD管道的可靠性

Co-authored-by: dakou <dakou@iflow.cn>
---
 .github/workflows/build-release-docker.yml | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/.github/workflows/build-release-docker.yml b/.github/workflows/build-release-docker.yml
index 9b0ec73..a2b1034 100644
--- a/.github/workflows/build-release-docker.yml
+++ b/.github/workflows/build-release-docker.yml
@@ -67,6 +67,12 @@ jobs:
       - uses: actions/setup-dotnet@v4
         with:
           dotnet-version: ${{ env.DOTNET_VERSION }}
+      - name: Code Quality Checks
+        run: |
+          echo "Running basic code quality checks..."
+          dotnet restore "${{ env.PROJECT_PATH }}"
+          dotnet build "${{ env.PROJECT_PATH }}" --verbosity normal --no-restore
+          echo "✓ Basic compilation check passed"
       - name: Publish
         run: |
           dotnet publish "${{ env.PROJECT_PATH }}" \
-- 
2.43.0

